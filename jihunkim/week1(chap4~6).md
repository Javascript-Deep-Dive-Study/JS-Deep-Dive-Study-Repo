## 4장 변수

> 프로그래밍 언어는 기억하고 싶은 값을 메모리에 저장하고, **저장된 값을 읽어 들여 재사용하기 위해** 변수라는 매커니즘(어떤 대상의 작동 원리나 구조)을 제공한다.

변수는 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름을 말한다.

간단하게 말하면, **값의 위치를 가리키는 상징적인 이름**인 것이다.

```javascript
var result = 10 + 20;
```

#### 식별자

> 변수 이름은 식별자라고 한다. 식별자는 어떤 값을 구별해서 식별할 수 있는 고유한 이름을 말한다.

값은 메모리 공간에 저장되어 있다. 따라서 식별자는 메모리 공간에 저장되어 있는 어떤 값을 구별해서 식별해 낼 수 있어야 한다. 이를 위해 식별자는 어떤 값이 저장되어 있는 메모리 주소를 기억(저장)해야 한다.

**이처럼, 식별자는 값이 아니라 메모리 주소를 기억하고 있다. 즉, 식별자는 메모리 주소에 붙인 이름이라고 할 수 있다.**



#### 변수선언

> 변수를 사용하려면 반드시 선언이 필요하다. 변수를 선언할 때는 var, let, const 키워드를 사용한다.

**변수의 선언 단계**

1. 선언 단계: 변수 이름을 동록해서 자바스크립트 엔진에 변수의 존재를 알린다.

2. 초기화 단계: 값을 저장하기 위한 메모리 공간을 확보하고 암묵적으로 undefined를 할당해 초기화한다.

   ❓일반적으로 초기화(Initialization)란 변수가 선언된 이후 최초로 값을 할당하는 것을 말함.

**var 키워드**

- 함수 레벨 스코프 / 이로 인해 의도치 않게 전역 변수가 선언되어 부작용이 발생

- Var 키워드를 사용한 변수 선언은 선언 단계와 초기화 단계가 동시에 진행된다. 



#### 변수 선언의 실행 시점과 변수 호이스팅

```javascript
console.log(score); // undefined
var score; // 변수 선언문
```

위 코드를 보면 변수 선언문보다 변수를 참조하는 코드가 앞에 있다. 자바스크립트 코드는 인터프리터에 의해 한 줄씩 순차적으로 실행되므로 console.log(score);가 가장 먼저 실행되고 순차적으로 다음 줄에 있는 코드를 실행한다. 

따라서 console.log(score);가 실행되는 시점에는 아직 score 변수의 선언이 실행되지 않았으므로 **참조 에러(ReferenceError)**가 발생할 것처럼 보인다. 하지만 참조 에러가 발생하지 않고 **undefined**가 출력된다. 

그 이유는 **변수 선언이 소스코드가 한 줄씩 순차적으로 실행되는 시점, 즉 런타임(runtime)이 아니라 그 이전 단계에서 먼저 실행되기 때문이다.**



> ## ❓TDZ(Temporal Dead Zone) - 일시적인 ~~녹색~~사각지대
>
> >  Javascript 변수 키워드에는 var, let, const가 있다.
>
> **var는 한번 선언된 변수를 다시 선언할 수 있다.**
>
> ```javascript
> var name = 'Jihun';
> console.log(name); // Jihun
> 
> var name = 'kimjihun';
> console.log(name); // Kimjihun
> ```
>
> **var는 선언하기 전에 사용할 수 있다.** 
>
> ```javascript
> console.log(name); // undefined
> var name = 'Jihun';
> ```
>
> **바로 호이스팅(hoisting)이 일어나기 때문이다.**
>
> ```javascript
> # 결과가 undefined가 발생되는 이유는 선언은 호이스팅되지만 할당은 호이스팅 되지 않기 때문이다.
> var name;// 값을 할당하지 않고 변수를 선언만 한 경우 자바스크립트 엔진은 해당 변수에 undefined값을 자동으로 할당한다.
> console.log(name); // undefined
> name = 'Jihun';
> ```
>
> 많은 Javascript 서적과 강좌에는 const, let은 호이스팅이 되지 않는다고 명시되어 있는 경우가 종종있다. 과연 그럴까? 여기서 정확하게 호이스팅의 뜻을 알아보자.
>
> **호이스팅이란 스코프 내부 어디서든 변수 선언은 최상위에 선언된 것처럼 행동하는 것을 의미한다.** 
>
> 그런데 var 키워드처럼 동작하지 않고 에러가 발생되는 걸까? 바로. **Temporal Dead Zone(TDZ)**라는 것 때문에 일어난다.
>
> ```javascript
> # hoisting
> console.log(name); // TDZ😱
> const name = 'Jihun’; // 함수 선언 및 할당
> console.log(name); //사용 가능
> ```
>
> 위에 TDZ 영역에 있는 변수들은 사용 가능하지 않는데, 바로 let과 const는 TDZ에 영향을 받기 때문이다. 이말은 곧 할당을 하기 전에는 사용할 수 없다는 말과 같으나 이는 코드를 예측가능하게 하고 잠재적은 버그를 줄일 수 있다는 장점을 갖는다.
>
> ```javascript
> # 이 코드는 문제가 없다.
> let age = 10;
> function showYourAge() {
> 	console.log(age);
> }
> showYourAge(); // 10
> 
> # 이 코드는 문제가 있다.
> let age = 10;
> function showYourAge() {
>   console.log(age);
>   let age = 20;
> }
> showYourAge(); // ReferenceError: Cannot access 'age' before initialization
> ```
>
> 앞서 말한 것처럼 let과 const는 호이스팅이 되지 않기 때문에 위에 작성된 2번째 코드에 발생되는 문제의 원인이라고 생각할 것이다.
>
> 호이스팅은 스코프 단위로 발생되는데, 위의 예시에서의 스코프는 함수 내부를 의미하며, 함수 안에서 let 키워드로 선언한 변수가 호이스팅을 일으킨다. **만약 let 키워드로 선언한 변수가 우리가 알고 있는 것처럼 호이스팅이 일어나지 않는다면 저 바깥에 선언한 let 키워드의 변수의 값 10이 출력되었어야 했다.** 
>
> **var 키워드는 선언과 동시에 초기화 단계가 이루어지지만, let 키워드는 선언 단계와 초기화 단계가 분리되어 있어, 호이스팅이 일어날 경우 선언 단계는 위로 끌어올려지지만 초기화 단계는 실제 코드에 도달할 대 실행되기 때문에 레퍼런스 에러가 발생되는 것이다.** 
>
> 
>
> 변수의 생성과정은 **1. 선언 단계, 2.초기화 단계, 3.할당 단계.**  총 3가지 단계로 구분지을 수 있다.
>
> > **var 키워드** 
> >
> > 1. 선언 및 초기화 단계
> > 2. 할당 단계
>
> > **let 키워드**
> >
> > 1. 선언 단계
> > 2. 초기화 단계 
> > 3. 할당 단계
>
> > **const 키워드**
> >
> > 1. (선언 + 초기화 + 할당) 단계
>
> 위에 설명대로 const 키워드로 변수 생성 시 선언, 초기화 및 할당을 동시에 선언하지 않으면 아래와 같은 에러가 발생된다.
>
> ```javascript
> let name;
> name = 'Jihun';
> 
> var age;
> age = 30;
> 
> # Uncaught SyntaxError: Missing initializer in const declaration
> const gender; // 선언만하고 할당은 하지 않았기 때문에 에러발생
> gender = 'male';
> ```
>
> 
>
> 그리고, **var, let, const** 키워드는 스코프도 서로 다르다.
>
> > var 키워드: 함수 레벨 스코프(function-level-scoped)
>
> ```javascript
> # 함수 레벨 스코프(function-level-scoped) - 함수블록내에서 선언된 변수는 해당 함수 블록내에서만 사용가능  하다.
> function addNum(num1, num2) {
>   var result = num1 + num2;
> }
> add(2, 3); // 5
> 
> # 함수블록 바깥에서 함수내부에서 var키워드로 선언된 result 호출시 에러가 발생 된다.
> console.log(result) // Uncaught ReferenceError: result is not defined.
> 
> # 하지만 var는 block-level-scoped가 아니기 때문에 블록 외부에서 사용가능하다.
> const age = 10;
> if(age >= 20) {
> 	var adult = '성인';
> }
> console.log(adult); // 성인
> ```
>
> 
>
> > let, const 키워드: 블록 레벨 스코프(block-level-scoped) - if 문, while문, tyr/catch문 등
>
> ```javascript
> # block-level-scoped - 코드블록내에서 선언된 변수는 해당 블록내에서만 사용가능하며, 외부에서는 접근할 수 없다. 즉, 한마디로 지역변수(local variable)이다.
> function name() {
> 	// block-level-scoped
> }
> 
> if() {
>    // block-level-scoped
> }
> 
> for(let i = 0; i <= 10; i++) {
>   // block-level-scoped
> }
> ```
>
> 
>
> 요약
>
> > **TDZ(Temporal Dead Zone)**란, 변수가 스코프의 시작 지점부터 초기화가 시작되는 지점까지의 구간을 말한다.



## 5장 표현식과 문

>  **용어정리**
>
> **값(value)**은 표현식(expresstion)이 평가(evaluate)되어 생성된 결과를 말한다. 평가란 식을 해석해서 값을 생성하거나 참조하는 것을 의미한다.
>
> ```javascript
> # 10 + 20은 평가되어 숫자 값 30을 생성한다.
> 10 + 20; // 30
> ```
>
> **리터럴(literal)**은 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 값을 생성하는 표기법(notation)을 말한다.
>
> ```javascript
> # 숫자 리터럴 
> 3
> # 문자열 리터럴
> 'Hello'
> "World"
> # 함수 리터럴
> function() {}
> ```

#### 표현식(expression)

**표현식(expression)**은 값으로 평가될 수 있는 문(statement)이다. 즉, 표현식이 평가되면 새로운 값을 생성하거나 기존 값을 참조한다. 그렇기 때문에 리터럴은 값이로 평가되며, 리터럴도 역시 표현식이다.

그냥, 값으로 평가될 수 있는 문은 모두 표현식이다.

```javascript
var score = 100;

var score = 50 + 50;
```

#### 문(statement)

**문(statement)**은 **프로그램을 구성하는 기본 단위이자 최소 실행 단위이다.** 문의 집합으로 이뤄진 것이 바로 프로그램이며, 문을 작성하고 순서에 맞게 나열하는 것이 곧 프로그래밍이다.

문은 여러 토큰으로 구성되는데, **토큰(token)**이란 **문법적인 의미를 가지며, 문법적으로 더 이상 나눌 수 없는 코드의 기본 요소를 의미한다.**

```javascript
# 토큰(token)
var sum = 1 + 2; // token: var, sum, =, 1, +, 2, ;
# 문(statement)
var sum = 1 + 2; // statement: var sum = 1 + 2;
```

>키워드, 식별자, 연산자, 리터럴, 세미콜론, 마침표 등의 특수 기호는 문법적인 의미를 가지며, 문법적으로 더 이상 나눌 수 없는 코드의 기본 요소이므로 모두 토큰이다.



#### 세미콜론과 세미콜론 자동 삽입 기능

세미콜론은 문의 종료를 나타낸다. 즉, 자바스크립트 엔진은 세미콜론으로 문이 종료한 위치를 파악하고 순차적으로 하나씩 문을 실행한다. 따라서 문을 끝낼 때는 세미콜론을 붙여야 한다. 단, 0개 이상의 문을 중괄호로 묶은 코드 블록({ .. }) 뒤에는 세미콜론을 붙이지 않는다. 예를 들어, if 문, for 문, 함수 등의 코드 블록 뒤에는 세미콜론을 붙이지 않는다. 이러한 코드 블록은 언제나 문의 종료를 의미하는 자체 종결성(self-closing)을 갖기 때문이다.

문의 끝에 붙이는 세미콜론은 옵션이다보니, 생략 가능한데, 자바스크립트 엔진이 소스코드를 해석할 때 문의 끝이라고 예측되는 지점에 세미콜론을 자동으로 붙여주는 세미콜론 자동 삽입 기능(ASI)이 암묵적으로 수행되고 있기 때문이다.



> ❓**그래서 세미콜론을 써? 말어?? 어???**
>
> 쓰지 말자는 주장이 다수를 차지한다고 하지만 나는 세미콜론을 쓰는게 더 낫다고 생각하는데 이유는 아래와 같다.
>
> ```javascript
> alert("에러가 발생합니다.")
> [1, 2].forEach(alert) // TypeError: Cannot read property '2' of undefined
> 
> alert("제대로 동작합니다.");
> [1, 2].forEach(alert) // "제대로 동작합니다.", 1, 2
> 
> # 세미콜론이 없을 때 에러가 발생했던 이유는 자바스크립트가 대괄호 [...] 앞에는 세미콜론이 있다고 가정하지 않기 때문이다. 따라서 세미콜론 자동 삽입이 일어나지 않고 첫 번째 코드는 단일 문으로 처리된다. 자바스크립트 엔지이 보게 될 코드는 다음과 같다.
> 
> alert("에러가 발생합니다.")[1, 2].forEach(alert) // 원래 이 코드는 단일 문이 아닌 두 개의 그저 서로 다른 문이었지만, 잘못 합쳐지면서 에러가 발생되었다.
> ```



#### 표현식인 문과 표현식이 아닌 문

```javascript
# 변수 선언문은 값으로 평가될 수 없으므로 표현식이 아니다.
var x; // 1, 2, 1 + 2, x = 1 + 2는 모두 표현식이다.
x = 1 + 2; // x = 1 + 2는 표현식이면서 완전한 문이기도 하다.
```

이처럼 표현식과 문은 비슷해서 구별하기 어렵다고 느낄 수 있다. 하지만 **표현식과 문을 구별하는 방법**은 의외로 간단한데 바로

**변수에 할당해 보는 것이다.** 표현식은 문은 값으로 평가되기 때문에 변수에 할당할 수 있다. 하지만 표현식이 아닌 문은 값으로 평가할 수 없으므로 변수에 할당하면 에러가 발생한다. 😁

```javascript
var x; // 변수 선언문은 표현식이 아닌 문이다.

x = 100; // 할당문은 그 자체가 표현식이지만 완전한 문이기도 하다. 즉, 할당문은 표현시인 문이다.

# 표현식이 아닌 문은 값처럼 사용할 수 없다.
var foo = var x; // SyntaxError: Unexpected token var
```



## 6장 데이터 타입

데이터 타입(data type)은 값의 종류를 말한다. 자바스크립트의 모든 값은 데이터 타입을 갖는다.

**Data type(자료형)**: 프로그래밍에서 프로그램이 처리할 수 있는 모든 것을 Data(자료)라고 부르며, 자료 형태에 따라 나눠 놓은 것을 Data Type(자료형)이라 한다.

> Javascript에서 제공하는 Data type(자료형)은 `number, string, boolean, null, undefined, obeject, symbol`이 있으며, 가장 기본적이면서도 많이 사용하는 자료형은 `number, string, boolean` 이다.

**number data type(숫자 자료형)**: Javascript는 소수점이 있는 숫자와 없는 숫자를 모두 같은 자료형으로 인식한다.

> ```
> > 123
> 123
> > 123.123 // 소숫점이 있던 없든 모두 같은 숫자 자료형
> 123.123
> ```

**boolean data type(불 자료형)**: `true` 와 `false` 두 값만 가지는 자료형이며, 두 대상을 비교할 수 있는 `비교 연산자`를 사용해도 해당 자료형을 만들 수 있다.

> | **비교 연산자** | **설 명**                                     |
> | --------------- | --------------------------------------------- |
> | **`==, ===`**   | 양쪽이 같다, 양쪽이 같다(자료형도 일치)       |
> | **`!=, !==`**   | 양쪽이 다르다, 양쪽이 다르다(자료형도 불일치) |
> | **`>`**         | 왼쪽이 더 크다                                |
> | **`<`**         | 오른쪽이 더 크다                              |
> | **`>=`**        | 왼쪽이 더 크거나 같다                         |
> | **`<=`**        | 오른쪽이 더 크거나 같다                       |
>
> ```
> > 12 > 123
> false
> > 10 === 10
> true
> > 10 === '10'
> false
> ```

**null data type(널 자료형)**: ‘존재하지 않는(nothing)’ 값, ‘비어 있는(empty)’ 값, ‘알 수 없는(unknown)’ 값을 나타내는 데 사용하는 자료형이다.

> ```
> > let age = null
> ```

**undefined data type(Undefined 자료형)**: '값이 할당되지 않은 상태’를 나타낼 때 사용하는 자료형이다.

> ```
> > let age // 변수는 선언했지만, 값을 할당하지 않았다면 해당 변수에 undefined가 자동으로 할당된다. 크..
> undefined
> > let name = 'Jihun Kim'
> > name = undefined
> undefined
> ```

**Object and symbol(객체와 심볼 자료형)**: `객체(object)`형은 특수한 자료형이며, 객체형을 제외한 다른 자료형은 문자열이든 숫자든 한 가지만 표현할 수 있기 때문에 원시(primitive) 자료형이라 부른다. `심볼(symbol)`형은 객체의 고유한 식별자(unique identifier)를 만들 때 사용한다.

> ❗**typeof 연산자**
>
> `typeof` 연산자는 두 가지 형태의 문법을 지원한다.
>
> > 연산자 형태: `typeof x`
> >
> > 함수 형태: `typeof(x)`
> >
> > ```
> > typeof undefined // "undefined"
> > 
> > typeof 0 // "number"
> > 
> > typeof 10n // "bigint"
> > 
> > typeof true // "boolean"
> > 
> > typeof "foo" // "string"
> > 
> > typeof Symbol("id") // "symbol"
> > 
> > typeof Math // "object" 
> > 
> > typeof null // "object" (Javascript 설계 실수이며 현재는 이전 개발된 프로그램과의 호환성등으로 수정하지 않음)
> > 
> > typeof alert // "function"
> > ```

> ❗**template literal(템플릿 리터럴) or template strings(템플릿 문자열)**
>
> 과거(ES6 이전) Javascript는 문자열 내부에 표현식을 삽입할 때 다음과 같은 문자열 연결 연산자(+)를 사용해야 했음
>
> ```
> > console.log('표현식 123 + 456의 값은 ' + (123 + 456) + '입니다!')
> 표현식 123 + 456의 값은 579입니다!
> ```
>
> 이런 작성법에 문제가 있는 건 아니지만, 표현식을 많이 결합할수록 코드가 복잡해진다. 그렇기 때문에 Javascript에서는 `template literal(템플릿 리터럴)`이라는 기능이 추가되어 코드를 간단하게 작성할 수 있다.
>
> template literal(템플릿 리터럴)은 backtick(`)기호로 감싸 만들며, 문자열 내부에 ${...}기호를 사용하여 표현식을 넣으면 표현식이 문자열 안에서 계산된다.
>
> ```
> > console.log(`표현식 123 + 456의 값은 ${123 + 456}입니다!`)
> 표현식 123 + 456의 값은 579입니다!
> ```