# chapter 7
>하나 이상의 표현식을 대상으로 산술, 할당, 비교, 논리, 타입, 지수 연산 등을 수행해 하나의 값을 만든다.
<pre>
👉 산술 연산자
5 * 4 // 20

👉 문자열 연결 연산자
'My name is' + 'Lee' // 'My name is Lee'

👉 할당 연산자
color = 'red' // 'red'

👉 비교 연산자
3 > 5 // false

👉 논리 연산자
true && false // false

👉 타입 연산자 
typeof Hi // string
</pre>


### 7.4 삼항 조건 연산자

![image](https://user-images.githubusercontent.com/79251654/126885868-58ae817a-490f-46f6-b113-4c9fca474efd.png)

> 첫 번째 피연산자가 true로 평가되면 두 번째 피연산자를 반환하고, 첫 번째 피연산자가 false로 평가되면 세 번째 피연산자를 반환한다. 즉, 삼항 조건 연산자는 두 번째 피연산자 또는 세 번째 피연산자로 평가되는 표현식이다.

<pre>
let num = 2;

let result = num % 2 ? '홀수' : '짝수'; // 2 % 2는 0이고 0은 false로 암묵적 타입이 변환된다.
</pre>

### 7.9 지수 연산자
> **ES7**에서 도입된 지수 연산자는 좌항의 피연산자를 밑으로, 우항의 피연산자를 지수로 거듭 제곱하여 숫자 값을 반환한다.
<pre>
 2 ** 2; // 4
 2 ** 2.5; // 5.65685424949238
 2 ** 0; // 1
 2 ** -2 // 0.25
</pre>

### 7.10 그 외의 연산자
|연산자|개요|
|:------|:---|
|?.|옵셔널 체이닝 연산자|
|??|null 병합 연산자|
|delete|프로퍼티 삭제|
|new|생성자 함수를 호출할 때 사용하여 인스턴스를 생성|
|instanceof|좌변의 객체가 우변의 생성자 함수와 연결된 인스턴스인지 판별|
|in|프로퍼티 존재 확인|


### 7.12 연산자 우선순위
|우선순위|연산자|
|------|:---|
|1|()|
|2|new(매개변수 존재),.[](프로퍼티 접근),()(함수호출),?.(옵셔널 체이닝 연산자)|
|3|new(매개변서 미존재)|
|4|X++,X--|
|5|!X,+X,-X,++X,--X,typeof,delete|
|6|** (이항연산자 중에서 우선순위가 가장 높음)|
|7|* ,/,%|
|8|+,-|
|9|<,<=,>,>=,in,instanceof|
|10|==,!==,===,!==|
|11|??(null 병합 연산자)|
|12|&&|
|13|ㅣㅣ|
|14|? ... : ...|
|15|할당 연산자(=,+=,-=,...)|
|16|,|

# chapter 8

### 제어문
>조건에 따라 코드블록을 실행(조건문)하거나 반복 실행(반복문)할 때 사용한다. 일반적으로 코드는 위에서 아래 방향으로 순차적으로 실행된다. 제어문을 사용하면 코드의 실행 흐름을 인위적으로 제어할 수 있다.
** 제어문을 바르게 이해하는 것은 코딩 스킬에 많은 영향을 준다. 특히 for문**

### 8.2 조건문
- if...else
- switch

#### 8.2.1 if else 문
<pre>
if(조건식){
  👉 조건식이 참이면 이 코드 블록이 실행된다.
} else {
  👉 조건식이 거짓이면 이 코드 블록이 실행된다.
}
</pre>
if문 조건식은 불리언 값으로 평가 되어야한다. 만약 불리언 값이 아닌 값으로 평가되면 자바스크립트 엔진에 의해 암묵적으로 불리언 값으로 강제 변환되어 실행할 코드 블록을 결정한다.

#### 조건문 삼항조건 연산자로 바꿔 쓰기
<pre>
let num = 2;
let result;

if(num % 2) {
 result = '홀수' ;
} else {
 result = '짝수';
}
</pre>

👇


<pre>
let result = num % 2 ? '홀수' : '짝수';
</pre>

#### 8.2.2 switch 문
> switch 문은 주어진 표현식을 평가하여 그 값과 일치하는 표현식을 갖는 case문으로 실행 흐름을 옮긴다. <br>case 문은 상황을 의미하는 표현식을 지정하고 콜론으로 마치고 그리고 그 뒤에 실행할 문들을 위치시킨다.
> <br> switch 문의 표현식과 일치하는 case문이 없다면 실행 순서는 default문으로 이동하며 default문은 사용 유무를 선택할 수 있다.

<pre>
switch (표현식){
  case표현식1 :
   switch 문의 표현식과 표현식1이 일치하면 실행될 문;
   break;
  case표현식2 :
   switch 문의 표현식과 표현식1이 일치하면 실행될 문;
   break;
  default :
   switch 문의 표현식과 일치하는 case문이 없을때 실행될 문;
}
</pre>

- if...else문은 논리적 참, 거짓으로 ㅅㄹ행할 코드 블록을 결정한다.
- switch문은 논리적 참, 거짓보다 다양한 상황(case)에 따라 실행할 코드 블록을 결정할 때 사용한다.

### 8.3 반복문
- for
- while
- do...while
> 자바스크립트는 배열을 순회할 때 사용하는 forEach 메서드, 객체의 프로퍼티를 열거할 때 사용하는 for..in문 이터러블을 순회할 수 있는 for..of문과 같이 반복문을 대체할 수 있는 다양한 기능을 제공한다.

#### 8.3.1 for문
<pre>
for ([초기문]; [조건문]; [증감문])
  조건식이 참인 경우 반복 실행될 문;
</pre>

#### 8.3.2 while문
- 주어진 조건식의 평가 결과가 참이면 코드 블록을 계속해서 반복 실행한다.
- 조건식 결과가 참이면 무한루프가 되며 무판루프를 벗어나려면 코드 블록내에 if문으로 탈출 조건을 만들고 break문으로 코드 블록을 탈출한다.
<pre>
while (조건문)
  문장
</pre>

> for문은 반복 횟수가 명확할 때 사용
> while문은 반복 횟수가 불명확할 때 사용한다.

#### 8.3.3 do...while문
- 코드 블록을 먼저 실행하고 조건식을 평가한다. 따라서 코드 블록은 무조건 한 번 이상 실행된다.
<pre>
do
  문장
while (조건문);
</pre>


### 8.4 break문
> 레이블 문, 반복문 (for, for...in, for...of, while, do...while) 또는 switch문의 코드 블록을 탈출한다. 레이블 문, 반복문, switch 문의 코드 블록 외 break 문을 사용하면 문법 에러가 발생한다.

### 8.5 continue 문
> 반복문의 코드 블록 실행을 현 지점에서 중단하고 반복문의 증감식으로 실행 흐름을 이동시킨다. break 문처럼 반복문을 탈출하지는 않는다.


# chapter 9

### 9.3 명시적 타입 변환

> 개발자 의도에 따라 명시적으로 타입을 변경하는 방법은 다양하다. 표준 빌트인 생성자 함수(String, Number, Boolean)를 new 연산자 없이 호출하는 방법과 빌트인 메서드를 사용하는 방법,
>  그리고 앞에서 살펴본 암묵적 타입 변환을 이용하는 방법이 있다.

#### 9.3.1 문자열 타입으로 변환
- String 생성자 함수를 new 연산자 없이 호출
- Object.prototype.toString 메서드를 사용
- 문자열 연결 연산자 이용

### 9.3.2 숫자 타입으로 변환
- Number 생성자 함수를 new 연산자 없이 호출
- parseInt, parseFloat 함수를 사용(문자열만 숫자타입으로 변환가능)
- + 단항 산술 연산자 이용
- * 산술 연산자 이용

#### 9.3.3 불리언 타입으로 변환
- Boolean 생성자 햠수를 new 연산자 없이 호출
- ! 부정 논리 연산자를 두 번 사용하는 방법

### 9.4 단축 평가
#### 9.4.1 논리 연산자를 사용한 단축 평가
- ll(and)
- &&(or)
|단축 평가 표현식|평가 결과|
|:------|:---|
|true ll anything|true|
|false ll anything|anyting|
|true && anything|anyting|
|false && anything|false|

# chapter 10

### 10.1 객체란?
- 원시 타입의 값, 즉 원시 값은 변경 불가능한 값이지만 객체 타입의 값, 즉 객체는 변경 가능한 값이다.
- 프로퍼티 : 객체의 상태를 나타내는 값(data)
- 메서드 : 프로퍼티(상태 데이터)를 참조하고 조작할 수 있는 동작

### 10.2 객체 리터럴에 의한 객체 생성
- 객체 리터럴
- Object 생성자 함수
- 생성자 함수
- Object.create 메서드
- 클래스(ES6)

### 10.3 프로퍼티
- 객체는 프로퍼티의 집합이며, 프로퍼티는 키와 값으로 구성된다.
- 프로퍼티 키  : 빈 문자열을 포함하는 모든 문자열 또는 심벌 값
- 프로퍼티 값 : 자바스크립트에 사용할수 있는 모든 값
- 식별자 네이밍 규칙을 따르지 않는 이름에는 반드시 따옴표를 사용해야 한다.


![image](https://user-images.githubusercontent.com/79251654/126889650-b2c99cc9-3ba7-4ab2-8bbf-9cd6a80404b4.png)

### 10.4 메서드
- 프로퍼티 값이 함수일 경우 일반 함수와 구분하기 위해서 메서드라 부른다. 즉 메서드는 객체에 묶여있는 함수를 말한다.

### 10.5 프로퍼티 접근
- 마침표 프로퍼티 접근 연산자(.)를 사용하는 마침표 표기법
- 대괄호 프로퍼티 접근 연산자[...]를 사용하는 대괄호 표기법

<pre>
let person = {
 name : 'Lee'
};

console.log(person.name) // 마침표 표기법에 의한 프로퍼티 접근
console.log(['name'] // 대괄호 표기법에 의한 프로퍼티 접근
</pre>

### 10.6 프로퍼티 값 갱신
- 이미 존재하는 프로퍼티에 값을 할당하면 값이 갱신된다.
<pre>
let person = {
 name : 'Lee'
};

person.name = 'Kim'
console.log(person) // {name : 'Kim'}
</pre>

### 10.7 프로퍼티 동적 생성
- 존재하지 않는 프로퍼티에 값을 할당하면 프로퍼티가 동적으로 생성되어 추가되고 프로퍼티 값이 할당된다.

<pre>
let person = {
 name : 'Lee;
};

person.age = 20;
console.log(person) // {name : 'Lee', age : 20}
</pre>

### 10.8 프로퍼티 삭제
<pre>
let person = {
 name : 'Lee;
};

person.age = 20;

delete person.age;

console.log(person) {name : 'Lee'}
</pre>

# chapter 12

### 12.1 함수란?

- 일련의 과정을 문으로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것이다.

![image](https://user-images.githubusercontent.com/79251654/126889988-b8840273-1916-4860-882e-fc0b5d64ab2e.png)

#### 12.4.3 함수 생성 시점과 함수 호이스팅
<pre>
// 함수 참조
console.dir(add); //f add(x,y)
console.dir(sub); // undefined

// 함수 호출
console.log(add(2,5)); // 7
console.log(sub(2.5)); // TypeError : sub is not a function

// 함수 선언문
function add(x,y) {
 return x + y;
}

// 함수 표현식
let sub = function (x, y) {
 return x - y;
);

</pre>

- 함수 선언문으로 정의한 함수는 함수 선언문 이전에 호출할 수 있다. 그러나 함수 표현식으로 정의한 함수는 표현식 이전에 호출할 수 없다. 이는 함수 선언문으로 정의한 함수와 함수 표현식으로 정의한 함수의 생성 시점이 다르기 때문이다.
- 이처럼 함수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징을 **함수 호이스팅**이라고 한다.
- 변수 선언은 런타임 이전에 실행되어 undefined로 초기화 되지만 변수 할당문의 값은 할당문이 실행되는 시점, 즉 런타임에 평가되는 함수 표현식의 함수 리터럴도 할당문이 실행되는 시점에 평가되어 함수 객체가 된다.
- 따라서 함수 표현식으로 함수를 정의하면 함수 호이스팅이 발생하는 것이 아니라 변수 호이스팅이 발생한다.




# ❗️ "this" 는 무엇인가?
<pre>
greeting: function() {
  alert('Hi! I\'m ' + this.name.first + '.');
}
</pre>

- this 키워드는 지금 동작하고 있는 코드를 가지고 있는 객체를 가리킨다.
- 자바스크립트에선 모든 함수에 this를 사용할 수 있다.
- this 값은 런타임에 결정됩니다. 컨텍스트에 따라 달라지고 동일한 함수라도 다른 객체에서 호출했다면 'this’가 참조하는 값이 달라진다.
- this 키워드는 지금 동작하고 있는 코드를 가지고 있는 객체를 가리킨다.
- 이 this 라는 녀석은 객체 멤버의 컨텍스트가 바뀌는 경우에도 언제나 정확한 값을 사용하게 해준다<br>

#### this가 만들어지는 이유
> 1. 일반 함수에서 this -> window
> 2. 중첩 함수에서 this -> window
> 3. 이벤트에서 this -> 이벤트 객체
> 4. 메소드에서 this -> 메소드 객체
> 5. 메소드 내부의 중첩 함수에서 this -> window

this - https://wormwlrm.github.io/2019/03/04/You-should-know-JavaScript-this.html<br>
this(MDN) - https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/this
